{"name":"Default Project","compositions":[{"id":"84294f37-cd0d-4674-a7d2-35d587c16f57","name":"Main Composition","width":1920,"height":1080,"fps":30.0,"duration":60.0,"background_color":{"r":0,"g":0,"b":0,"a":255},"color_profile":"sRGB","tracks":[{"id":"cd5d6dc4-8d7b-4706-9b12-80f93c4f8d80","name":"New Track","clips":[{"id":"fb32be0c-bc9a-4d77-9adc-2392fe31a328","reference_id":null,"type":"sksl","in_frame":0,"out_frame":143,"source_begin_frame":0,"duration_frame":null,"fps":0.0,"properties":{"anchor_y":{"type":"constant","properties":{"value":540.0}},"opacity":{"type":"constant","properties":{"value":100.0}},"position_x":{"type":"constant","properties":{"value":960.0}},"anchor_x":{"type":"constant","properties":{"value":960.0}},"position_y":{"type":"constant","properties":{"value":540.0}},"shader":{"type":"constant","properties":{"value":"// Constants defined using 'const' keyword\nconst float PI = 3.14159265359;\nconst int Type = 5;\nconst float MAX_TRACE_DISTANCE = 10.0;\nconst float INTERSECTION_PRECISION = 0.001;\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float GAMMA = 2.2;\n\n\n//--------------------------------\n// Utilities and Math Functions\n//--------------------------------\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\n// Rotate around a coordinate axis.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal) + offset;\n    if (t < 0.0) {\n        p = p - (2.0 * t) * planeNormal;\n    }\n    return sign(t);\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,      oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,       oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\n\n//--------------------------------\n// Signed Distance Functions (SDF) and Operations\n//--------------------------------\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0.0))) + vmax(min(d, vec3(0.0)));\n}\n\n// Distance to line segment\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab)); // uses built-in saturate\n    return length((ab * t + a) - p);\n}\n\n// Capsule\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    return fLineSegment(p, a, b) - r;\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\nfloat fPlane(vec3 p, vec3 a, vec3 b, vec3 c, vec3 inside, float distanceFromOrigin) {\n    vec3 n = normalize(cross(c - b, a - b));\n    float d = -dot(a, n);\n\n    if (dot(n, inside) + d > 0.0) {\n        n = -n;\n        d = -d;\n    }\n\n    return fPlane(p, n, d + distanceFromOrigin);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n    float m = max(a, b);\n    if ((-a < r) && (-b < r)) {\n        return max(m, -(r - sqrt((r + a) * (r + a) + (r + b) * (r + b))));\n    } else {\n        return m;\n    }\n}\n\n// Cone with correct distances to tip and base circle.\nfloat fCone(vec3 p, float radius, float height) {\n    vec2 q = vec2(length(p.xz), p.y);\n    vec2 tip = q - vec2(0.0, height);\n    vec2 mantleDir = normalize(vec2(height, radius));\n    float mantle = dot(tip, mantleDir);\n    float d = max(mantle, -q.y);\n    float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\n    // distance to tip\n    if ((q.y > height) && (projected < 0.0)) {\n        d = max(d, length(tip));\n    }\n\n    // distance to base ring\n    if ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n        d = max(d, length(q - vec2(radius, 0.0)));\n    }\n    return d;\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n    float m = min(a, b);\n    if ((a < r) && (b < r) ) {\n        return min(m, r - sqrt((r - a) * (r - a) + (r - b) * (r - b)));\n    } else {\n        return m;\n    }\n}\n\n// Cone with direction\nfloat fCone(vec3 p, float radius, float height, vec3 direction) {\n    p = reflect(p, normalize(mix(vec3(0.0, 1.0, 0.0), -direction, 0.5)));\n    return fCone(p, radius, height);\n}\n\n\n//--------------------------------\n// Icosahedron Logic and Model\n//--------------------------------\n\n// Global variables for Icosahedron initialization\nvec3 nc, pab, pbc, pca;\nvec3 icoF0;\nvec3 icoF1a;\nvec3 icoA0, icoB0, icoC0;\nvec3 icoA1, icoB1, icoC1;\nvec3 fold1, fold2, fold3;\n\n// Barycentric to Cartesian\nvec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {\n    return barycentric.x * A + barycentric.y * B + barycentric.z * C;\n}\n\nvoid initIcosahedron() {\n    float cospin = cos(PI / float(Type));\n    float scospin = sqrt(0.75 - cospin * cospin);\n\n    nc = vec3(-0.5, -cospin, scospin);\n    pab = vec3(0.0, 0.0, 1.0);\n    pbc = vec3(scospin, 0.0, 0.5);\n    pca = vec3(0.0, scospin, cospin);\n    pbc = normalize(pbc);\n    pca = normalize(pca);\n\n    vec3 A = pbc;\n    vec3 C = reflect(A, normalize(cross(pab, pca)));\n    vec3 B = reflect(C, normalize(cross(pbc, pca)));\n\n    icoF0 = pca;\n\n    icoA0 = A;\n    icoC0 = B;\n    icoB0 = C;\n\n    vec3 p1 = bToC(A, B, C, vec3(0.5, 0.0, 0.5));\n    vec3 p2 = bToC(A, B, C, vec3(0.5, 0.5, 0.0));\n    fold1 = normalize(cross(p1, p2));\n\n    // Get corners of triangle created by fold\n    vec3 A2 = reflect(A, fold1);\n    vec3 B2 = p1;\n    vec3 C2 = p2;\n\n    icoF1a = pca;\n\n    icoA1 = A2;\n    icoB1 = normalize(B2);\n    icoC1 = normalize(C2);\n\n    p1 = bToC(A2, B2, C2, vec3(0.5, 0.0, 0.5));\n    p2 = bToC(A2, B2, C2, vec3(0.5, 0.5, 0.0));\n    fold2 = normalize(cross(p1, p2));\n\n    p1 = bToC(A2, B2, C2, vec3(0.0, 0.5, 0.5));\n    fold3 = normalize(cross(p2, p1));\n}\n\n\nfloat pModIcosahedron(inout vec3 p, int subdivisions) {\n    p = abs(p);\n    pReflect(p, nc, 0.0);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.0);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.0);\n\n    float i = 0.0;\n\n    if (subdivisions > 0) {\n        // Fold in corner A\n        i += pReflect(p, fold1, 0.0) / 2.0 + 0.5;\n\n        if (subdivisions > 1) {\n            // Fold in corner A\n            pReflect(p, fold2, 0.0);\n\n            // Fold in corner B\n            pReflect(p, fold3, 0.0);\n        }\n    }\n\n    return i;\n}\n\nvec3 pRoll(inout vec3 p, float t) {\n    pR(p.yx, PI / 3.0);\n    pR(p.yz, PI / -5.0);\n    mat3 m = rotationMatrix(normalize(icoF1a), t * ((PI * 2.0) / 3.0));\n    p *= m;\n    return p;\n}\n\nfloat fHolePart(\n    vec3 p,\n    vec3 a,\n    vec3 b,\n    vec3 c,\n    vec3 d,\n    float round,\n    float thick\n) {\n    vec3 center = (a + b + c + d) / 4.0;\n    float f0 = fPlane(p, a, b, c, center, thick);\n    float f1 = fPlane(p, a, c, d, center, thick);\n    float f = f0;\n    f = fOpIntersectionRound(f, f1, round);\n    return f;\n}\n\n\nfloat fHole(\n    vec3 p,\n    vec3 a,\n    vec3 b,\n    vec3 c\n) {\n    float w = 1.0;\n    float h = 1.0;\n    const float round = 0.08;\n    const float thick = 0.02;\n\n    vec3 AB = mix(a, b, 0.5);\n    vec3 AAB = mix(a, b, w);\n    vec3 ABB = mix(a, b, 1.0 - w);\n    vec3 n = normalize(cross(a, b));\n    vec3 cn = dot(c, n) * n;\n    vec3 AF = c - cn * (1.0 - h);\n    vec3 AF2 = reflect(AF, n);\n\n    float part1 = fHolePart(p, vec3(0.0), AF2, AAB, AF, round, thick);\n    float part2 = fHolePart(p, vec3(0.0), AF2, ABB, AF, round, thick);\n    float hole = fOpIntersectionRound(part1, part2, round);\n    return hole;\n}\n\nfloat holes(vec3 p, float i) {\n    float d = 1000.0;\n\n    if (i > 0.0) {\n        return min(d, fHole(p, icoC1, icoB1, icoF1a));\n    }\n\n    d = min(d, fHole(p, icoC1, icoB1, icoF1a));\n    d = min(d, fHole(p, icoA1, icoB1, icoF1a));\n    return d;\n}\n\nfloat spikes(vec3 p) {\n    float d = 1000.0;\n    d = min(d, fCone(p, 0.05, 1.3, icoF1a));\n    d = min(d, fCone(p, 0.05, 1.7, icoA1));\n    d = min(d, fCone(p, 0.05, 1.8, icoB1));\n    return d;\n}\n\nfloat shell(vec3 p, float i) {\n\n    const float thick = 0.03;\n    const float round = 0.015;\n\n    float d = length(p) - 1.0;\n    d = fOpUnionRound(d, spikes(p), 0.12);\n    d = max(d, -(length(p) - (1.0 - thick)));\n    float h = holes(p, i);\n    h = max(h, (length(p) - 1.1)); // Stop holes clipping spikes\n    d = fOpIntersectionRound(d, -h, round);\n    return d;\n}\n\nfloat model(vec3 p, float time) {\n    pRoll(p, time);\n\n    float i = 0.0;\n\n    i = pModIcosahedron(p, 1);\n    float d = shell(p, i);\n    return d;\n}\n\nvec2 map( vec3 p, float time ){\n    vec2 res = vec2(model(p, time), 1.0);\n    return res;\n}\n\n\n//--------------------------------\n// Raymarching and Lighting\n//--------------------------------\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd, float time ){\n    float h = INTERSECTION_PRECISION * 2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.0;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        vec2 m = map( ro + rd * t, time );\n        h = m.x;\n        t += h;\n        id = m.y;\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n\n    return vec2( res , id );\n}\n\nvec3 calcNormal( in vec3 pos, float time ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos + eps.xyy, time).x - map(pos - eps.xyy, time).x,\n        map(pos + eps.yxy, time).x - map(pos - eps.yxy, time).x,\n        map(pos + eps.yyx, time).x - map(pos - eps.yyx, time).x );\n    return normalize(nor);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd * t, time ).x;\n        res = min( res, 8.0 * h / t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h < 0.001 || t > tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor, float time )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = map( aopos, time ).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );\n}\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB)\n{\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvec3 doLighting(vec3 col, vec3 pos, vec3 nor, vec3 ref, vec3 rd, float time) {\n\n    // lighitng\n    float occ = calcAO( pos, nor, time );\n    vec3  lig = normalize( vec3(-0.6, 0.7, 0.5) );\n    float amb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float fre = pow( clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0 );\n\n    dif *= softshadow( pos, lig, 0.02, 2.5, time );\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(0.95, 0.80, 0.60);\n    lin += 0.80 * amb * vec3(0.50, 0.70, 0.80) * occ;\n    lin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.20 * fre * vec3(1.00, 1.00, 1.00) * occ;\n    col = col * lin;\n\n    return col;\n}\n\nvec3 render( vec2 res , vec3 ro , vec3 rd, float time ){\n\n    vec3 color = vec3(0.04, 0.045, 0.05);\n\n    if( res.y > -0.5 ){\n\n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos, time );\n        vec3 ref = reflect(rd, norm);\n\n        color = vec3(0.5);\n        color = doLighting(color, pos, norm, ref, rd, time);\n    }\n\n    return color;\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    vec3 orient = normalize(vec3(0.1, 1.0, 0.0));\n    const float zoom_base = 4.0;\n    float zoom = zoom_base;\n    zoom -= mouse.y * 3.5;\n    camPos = zoom * orient;\n    camTar = vec3(0.0);\n}\n\n\n//--------------------------------\n// SKSL Fragment Shader Entry Point\n//--------------------------------\n\n// fragCoord is automatically defined by the runtime\nhalf4 main(float2 fragCoord) {\n    float t = iTime;\n    t = mod(t / 4.0, 1.0);\n\n    initIcosahedron();\n\n    // p is normalized device coordinate (NDC) scaled by aspect ratio\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    // m is normalized mouse coordinate\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3( 0.0, 0.0, 2.0);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n    // camera movement\n    doCamera(ro, ta, iTime, m);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );\n\n    // create view ray (2.0 is the lens length/focal length)\n    vec3 rd = normalize( camMat * vec3(p.xy, 2.0) );\n\n    vec2 res = calcIntersection( ro , rd, t );\n\n    vec3 color = render( res , ro , rd, t );\n    color = linearToScreen(color);\n\n    return half4(color, 1.0);\n}          "}},"scale_x":{"type":"constant","properties":{"value":100.0}},"rotation":{"type":"constant","properties":{"value":0.0}},"scale_y":{"type":"constant","properties":{"value":100.0}}},"effects":[]}]}]}],"assets":[],"export":{"container":null,"codec":null,"pixel_format":null,"ffmpeg_path":null,"parameters":{}}}