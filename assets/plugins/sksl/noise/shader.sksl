uniform shader content;
uniform float amount;
uniform float seed;
uniform int monochrome;
uniform int animate;
uniform float speed;
uniform int blend_mode; // 0=Add, 1=Overlay
uniform float u_time;

// Simple hash for white noise
float hash(float2 p) {
    return fract(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}

// Box-Muller transform for Gaussian Noise
float gaussian(float2 p, float seed_val) {
    // Generate two uniform randoms
    float u1 = hash(p + float2(seed_val, seed_val * 3.1));
    float u2 = hash(p + float2(seed_val * 7.3, seed_val));

    // Avoid log(0)
    u1 = max(u1, 0.0001);

    // Box-Muller
    float r = sqrt(-2.0 * log(u1));
    float theta = 6.283185 * u2;

    return r * cos(theta); // Standard normal distribution (mean=0, std=1)
}

half4 main(float2 p) {
    half4 color = content.eval(p);

    float t = seed;
    if (animate != 0) {
        t += u_time * speed;
    }

    float3 noise_val;
    if (monochrome != 0) {
        float g = gaussian(p, t);
        noise_val = float3(g);
    } else {
        float r = gaussian(p, t);
        float g = gaussian(p + 17.0, t + 23.0);
        float b = gaussian(p + 31.0, t + 47.0);
        noise_val = float3(r, g, b);
    }

    // Noise Amount scaling
    // Gaussian std dev is 1.0. We scale by amount.
    noise_val *= amount;

    if (blend_mode == 0) {
        // Additive (Simple)
        color.rgb += noise_val;
    } else {
        // Overlay (Contrast preserving)
        // If base < 0.5: 2 * base * (0.5 + noise) -- approximation
        // Standard Overlay:
        // if c < 0.5: 2 * c * n
        // if c > 0.5: 1 - 2 * (1-c) * (1-n)
        // Here our noise is centered at 0.
        // Let's map noise to 0..1 for standard formula?
        // Or use "Soft Light".

        // Simplified Overlay with centered noise:
        // color + (2 * color - 1) * noise? No.

        // Soft Light implementation (Pegtop)
        // (1 - 2*n) * c^2 + 2*n*c

        // Let's stick to simple "Grain" addition which is usually multiplicative in shadows?
        // Film grain is visible in midtones, less in highlights/shadows.

        // Luminance weighting:
        // float luma = dot(color.rgb, half3(0.299, 0.587, 0.114));
        // noise_val *= (1.0 - abs(luma - 0.5) * 2.0); // Peak at 0.5 ??

        // Let's just use Standard Overlay logic with re-mapped noise.
        // Map Gaussian (-inf..inf) roughly to 0..1.
        // 0 -> 0.5. Range +/- 0.5 covers 1 sigma?
        // let n_norm = clamp(noise_val + 0.5, 0.0, 1.0);

        // Apply per channel
        float3 c = color.rgb;
        float3 n_norm = noise_val + 0.5; // Center around 0.5

        // Branchless Overlay approximation
        // f(c, n) = c < 0.5 ? (2.0*c*n) : (1.0 - 2.0*(1.0-c)*(1.0-n));

        float3 r1 = 2.0 * c * n_norm;
        float3 r2 = 1.0 - 2.0 * (1.0 - c) * (1.0 - n_norm);

        float3 overlay = mix(r1, r2, step(0.5, c));

        // Mix original and overlay based on amount?
        // No, we already scaled noise_val by amount.
        // But n_norm is shifted.
        // If amount is 0, noise_val is 0, n_norm is 0.5.
        // Overlay with 0.5 is Identity. Correct.

        color.rgb = overlay;
    }

    return color;
}
